<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>LXC 1.0: QuickStart</title>
<style type="text/css">

/*
:Author: Your Name
:Contact: Your Email Address
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.  [Optionally place a more
detailed description here.]
*/

/*@import url(reset.css);*/
@import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu|Ubuntu+Light);

/* Your customizations go here.  For example: */

html {

background: #EFEFEF

}

body {

font-size: 16px;
line-height: 1.5;
text-align: justify;
padding: 40px 40px 20px;
-moz-box-shadow: 0 0 3px #c9c9c9;
-webkit-box-shadow: 0 0 3px #c9c9c9;
box-shadow: 0 0 3px #c9c9c9;
-webkit-box-sizing: border-box;
-moz-box-sizing: border-box;
box-sizing: border-box;
-webkit-border-radius: 4px;
-moz-border-radius: 4px;
border-radius: 4px;
background: #fff;
clear: both;
display: block;
width: 100%;
margin: 10px 0 30px;
padding-bottom: 20px;
position: relative;
z-index: 1;
width: 984px;
clear: both;
margin: 0 auto;

}

.title {

background-color: #DD4814;
color: #fff;
font-family: 'Ubuntu';
font-weight: bold;
padding-left: 40px;
margin: 20px 50px 100px;

}

h1, h2, h3, h4, h5, h6, p.topic-title {

  font-family: 'Ubuntu Light', sans-serif; 

}

p, a, li {

  font-family: 'Ubuntu', sans-serif;

}

a {

color: #dd4814;
text-decoration: none;


}

h1 a {

font-size: 45px;
text-align: center;
color: #333;
text-decoration: none;

}

h2 a {

font-size: 32px;
color: #dd4814;
text-decoration: none;

}

p, li {

color: #333;

}

.code, .literal-block, .pre, .literal {

background-color: #EFEFEF;

}

</style>
</head>
<body>
<div class="document" id="lxc-1-0-quickstart">
<h1 class="title">LXC 1.0: QuickStart</h1>

<!-- -*- coding: utf-8 -*- -->
<div class="section" id="summary">
<h1><a class="toc-backref" href="#id10">Summary</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#summary" id="id10">Summary</a></li>
<li><a class="reference internal" href="#intro-blog-post-series" id="id11">Intro.  Blog post series</a></li>
<li><a class="reference internal" href="#id1" id="id12">1. Your first Ubuntu container</a><ul>
<li><a class="reference internal" href="#so-whats-lxc" id="id13">So what’s LXC ?</a></li>
<li><a class="reference internal" href="#lxc-1-0" id="id14">LXC 1.0</a></li>
<li><a class="reference internal" href="#how-to-get-it" id="id15">How to get it ?</a></li>
<li><a class="reference internal" href="#what-about-that-first-container" id="id16">What about that first container ?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2" id="id17">2. Your second container</a><ul>
<li><a class="reference internal" href="#more-templates" id="id18">More templates</a></li>
<li><a class="reference internal" href="#auto-start" id="id19">Auto-start</a></li>
<li><a class="reference internal" href="#freezing-your-containers" id="id20">Freezing your containers</a></li>
<li><a class="reference internal" href="#networking" id="id21">Networking</a></li>
<li><a class="reference internal" href="#attach" id="id22">Attach</a></li>
<li><a class="reference internal" href="#passing-devices-to-a-running-container" id="id23">Passing devices to a running container</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4" id="id24">3. Advanced container usage</a><ul>
<li><a class="reference internal" href="#exchanging-data-with-a-container" id="id25">Exchanging data with a container</a></li>
<li><a class="reference internal" href="#container-nesting" id="id26">Container nesting</a></li>
<li><a class="reference internal" href="#raw-network-access" id="id27">Raw network access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id28">4. Some more advanced container usage</a><ul>
<li><a class="reference internal" href="#running-foreign-architectures" id="id29">Running foreign architectures</a></li>
<li><a class="reference internal" href="#hooks" id="id30">Hooks</a></li>
<li><a class="reference internal" href="#android-containers" id="id31">Android containers</a></li>
<li><a class="reference internal" href="#lxc-on-android-devices" id="id32">LXC on Android devices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8" id="id33">5. Container storage</a><ul>
<li><a class="reference internal" href="#storage-backingstores" id="id34">Storage backingstores</a><ul>
<li><a class="reference internal" href="#directory-based-storage-none-and-dir" id="id35">directory based storage (none and dir)</a></li>
<li><a class="reference internal" href="#btrfs" id="id36">btrfs</a></li>
<li><a class="reference internal" href="#lvm" id="id37">lvm</a></li>
<li><a class="reference internal" href="#overlayfs" id="id38">overlayfs</a></li>
<li><a class="reference internal" href="#zfs" id="id39">zfs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-paths" id="id40">Standard paths</a></li>
<li><a class="reference internal" href="#cloning-containers" id="id41">Cloning containers</a></li>
<li><a class="reference internal" href="#snapshotting" id="id42">Snapshotting</a></li>
</ul>
</li>
</ul>
</div>
<!-- -*- coding: utf-8 -*- -->
</div>
<div class="section" id="intro-blog-post-series">
<h1><a class="toc-backref" href="#id11">Intro.  Blog post series</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/20</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>So it’s almost the end of the year, I’ve got about 10 days of vacation for the holidays and a bit of time on my hands.</p>
<p>Since I’ve been doing quite a bit of work on LXC lately in prevision for the <a class="reference external" href="http://linuxcontainers.org/">LXC</a> 1.0 release early next year, I thought that it’d be a good use of some of that extra time to blog about the current state of LXC.</p>
<p>As a result, I’m preparing a series of 10 blog posts covering what I think are some of the most exciting features of LXC. The planned structure is:</p>
<ul class="simple">
<li><a class="reference external" href="../../_build/en/index.html#your-first-ubuntu-container">1. Your first Ubuntu container</a></li>
<li><a class="reference external" href="../../_build/en/index.html#your-second-container">2. Your second container</a></li>
<li><a class="reference external" href="../../_build/en/index.html#advanced-container-usage">3. Advanced container usage</a></li>
<li><a class="reference external" href="../../_build/en/index.html#lxc-1-0-some-more-advanced-container-usage">4. Some more advanced container usage</a></li>
<li><a class="reference external" href="../../_build/en/index.html#lxc-1-0-container-storage">5. Container storage</a></li>
<li>LXC 1.0: Security features [6/10]</li>
<li>LXC 1.0: Unprivileged containers [7/10]</li>
<li>LXC 1.0: Scripting with the API [8/10]</li>
<li>LXC 1.0: GUI in containers [9/10]</li>
<li>LXC 1.0: Troubleshooting and debugging [10/10]</li>
</ul>
<p>While they are all titled LXC 1.0, most of the things I’ll be showing will work just as well on older LXC. However some of the features will need a very very recent version of LXC (as in, current upstream git). I’ll try to make that clear and will explain how to use our <a class="reference external" href="https://launchpad.net/ubuntu/+source/lxc">stable backports in Ubuntu</a> or <a class="reference external" href="https://launchpad.net/~ubuntu-lxc/+archive/daily">current upstream snapshots from our PPA</a>.</p>
<p>I’ll be updating this first blog post with links to all of the posts in the series. So if you want to bookmark or refer to these, please use this post.</p>
<!-- -*- coding: utf-8 -*- -->
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id12">1. Your first Ubuntu container</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/20</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>This is post 1 out of 10 in the <a class="reference external" href="../../_build/en/index.html#intro-blog-post-series">LXC 1.0 blog post series</a>.</p>
<div class="section" id="so-whats-lxc">
<h2><a class="toc-backref" href="#id13">So what’s LXC ?</a></h2>
<p>Most of you probably already know the answer to that one, but here it goes:</p>
<blockquote class="epigraph">
<em>“LXC is a userspace interface for the Linux kernel containment features.</em>
<em>Through a powerful API and simple tools, it lets Linux users easily create and manage system or application containers.”</em></blockquote>
<p>I’m one of the two upstream maintainers of LXC along with Serge Hallyn.</p>
<p>The project is quite actively developed with milestones every month and a stable release coming up in February. It’s so far been developed by 67 contributors from a wide range of backgrounds and companies.</p>
<p>The project is mostly developed on github: <a class="reference external" href="http://github.com/lxc">http://github.com/lxc</a></p>
<p>We have a website at: <a class="reference external" href="http://linuxcontainers.org">http://linuxcontainers.org</a></p>
<p>And mailing lists at: <a class="reference external" href="http://lists.linuxcontainers.org">http://lists.linuxcontainers.org</a></p>
</div>
<div class="section" id="lxc-1-0">
<h2><a class="toc-backref" href="#id14">LXC 1.0</a></h2>
<p>So what’s that 1.0 release all about?</p>
<p>Well, simply put it’s going to be the first real stable release of LXC and the first we’ll be supporting for 5 years with bugfix releases. It’s also the one which will be included in Ubuntu 14.04 LTS to be released in April 2014.</p>
<p>It’s also going to come with a stable API and a set of bindings, quite a few interesting new features which will be detailed in the next few posts and support for a wide range of host and guest distributions (including Android).</p>
</div>
<div class="section" id="how-to-get-it">
<h2><a class="toc-backref" href="#id15">How to get it ?</a></h2>
<p>I’m assuming most of you will be using Ubuntu. For the next few posts, I’ll myself be using the current upstream daily builds on Ubuntu 14.04 but we maintain daily builds on 12.04, 12.10, 13.04, 13.10 and 14.04, so if you want the latest upstream code, you can use <a class="reference external" href="https://launchpad.net/~ubuntu-lxc/+archive/daily">our PPA</a>.</p>
<p>Alternatively, LXC is also directly in Ubuntu and quite usable since Ubuntu 12.04 LTS. You can choose to use the version which comes with whatever release you are on, or you can use one the backported version we maintain.</p>
<p>If you want to build it yourself, you can do (not recommended when you can simply use the packages for your distribution):</p>
<pre class="code literal-block">
git clone git://github.com/lxc/lxc
cd lxc
sh autogen.sh
# You will probably want to run the configure script with --help and then set the paths
./configure
make
sudo make install
</pre>
</div>
<div class="section" id="what-about-that-first-container">
<h2><a class="toc-backref" href="#id16">What about that first container ?</a></h2>
<p>Oh right, that was actually the goal of this post wasn’t it?</p>
<p>Ok, so now that you have LXC installed, hopefully using the Ubuntu packages, it’s really as simple as:</p>
<pre class="code literal-block">
# Create a &quot;p1&quot; container using the &quot;ubuntu&quot; template and the same version of Ubuntu
# and architecture as the host. Pass &quot;-- --help&quot; to list all available options.
sudo lxc-create -t ubuntu -n p1

# Start the container (in the background)
sudo lxc-start -n p1 -d

# Enter the container in one of those ways
## Attach to the container's console (ctrl-a + q to detach)
sudo lxc-console -n p1

## Spawn bash directly in the container (bypassing the console login),
## requires a &gt;= 3.8 kernel
sudo lxc-attach -n p1

## SSH into it
sudo lxc-info -n p1
ssh ubuntu&#64;&lt;ip from lxc-info&gt;

# Stop the container in one of those ways
## Stop it from within
sudo poweroff

## Stop it cleanly from the outside
sudo lxc-stop -n p1

## Kill it from the outside
sudo lxc-stop -n p1 -k
</pre>
<p>And there you go, that’s your first container. You’ll note that everything usually just works on Ubuntu. Our kernels have support for all the features that LXC may use and our packages setup a bridge and a DHCP server that the containers will use by default.
All of that is obviously configurable and will be covered in the coming posts.</p>
<!-- -*- coding: utf-8 -*- -->
</div>
</div>
<div class="section" id="id2">
<h1><a class="toc-backref" href="#id17">2. Your second container</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/21</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>This is post 2 out of 10 in the <a class="reference external" href="../../_build/en/index.html#intro-blog-post-series">LXC 1.0 blog post series</a>.</p>
<div class="section" id="more-templates">
<h2><a class="toc-backref" href="#id18">More templates</a></h2>
<p>So at this point you should have a working Ubuntu container that’s called <tt class="docutils literal">p1</tt> and was created using the default template called simply enough <tt class="docutils literal">ubuntu</tt>.</p>
<p>But LXC supports much more than just standard Ubuntu. In fact, in <a class="reference external" href="https://github.com/lxc/lxc/tree/master/templates">current upstream git</a> (and daily PPA), we support Alpine Linux, Alt Linux, Arch Linux, busybox, CentOS, Cirros, Debian, Fedora, OpenMandriva, OpenSUSE, Oracle, Plamo, sshd, Ubuntu Cloud and Ubuntu.</p>
<p>All of those can usually be found in /usr/share/lxc/templates. They also all typically have extra advanced options which you can get to by passing <tt class="docutils literal"><span class="pre">--help</span></tt> after the <tt class="docutils literal"><span class="pre">lxc-create</span></tt> call (the <tt class="docutils literal"><span class="pre">--</span></tt> is required to split <tt class="docutils literal"><span class="pre">lxc-create</span></tt> options from the template’s).</p>
<p>Writing extra templates isn’t too difficult, they basically are executables (all shell scripts but that’s not a requirement) which take a set of standard arguments and are expected to produce a working rootfs in the path that’s passed to them.</p>
<p>One thing to be aware of is that due to missing tools not all distros can be bootstrapped on all distros. It’s usually best to just try. We’re always interested in making those work on more distros even if that means using some rather weird tricks (like is done in the fedora template) so if you have a specific combination which doesn’t work at the moment, patches are definitely welcome!</p>
<p>Anyway, enough talking for now, let’s go ahead and create an Oracle Linux container that we’ll force to be 32bit.</p>
<pre class="code literal-block">
sudo lxc-create -t oracle -n p2 -- -a i386
</pre>
<p>On most systems, this will initially fail, telling you to install the “rpm” package first which is needed for bootstrap reasons. So install it and “yum” and then try again.</p>
<p>After some time downloading RPMs, the container will be created, then it’s just a:</p>
<pre class="code literal-block">
sudo lxc-start -n p2
</pre>
<p>And you’ll be greated by the Oracle Linux login prompt (root / root).</p>
<p>At that point since you started the container without passing “-d” to “lxc-start”, you’ll have to shut it down to get your shell back (you can’t detach from a container which wasn’t started initially in the background).</p>
<p>Now if you are wondering why Ubuntu has two templates. The Ubuntu template which I’ve been using so far does a local bootstrap using “debootstrap” basically building your container from scratch, whereas the Ubuntu Cloud template (ubuntu-cloud) downloads a pre-generated cloud image (identical to what you’d get on EC2 or other cloud services) and starts it. That image also includes cloud-init and supports the standard cloud metadata.</p>
<p>It’s a matter of personal choice which you like best. I personally have a local mirror so the “ubuntu” template is much faster for me and I also trust it more since I know everything was downloaded from the archive in front of me and assembled locally on my machine.</p>
<p>One last note on templates. Most of them use a local cache, so the initial bootstrap of a container for a given arch will be slow, any subsequent one will just be a local copy from the cache and will be much faster.</p>
</div>
<div class="section" id="auto-start">
<h2><a class="toc-backref" href="#id19">Auto-start</a></h2>
<p>So what if you want to start a container automatically at boot time?</p>
<p>Well, that’s been supported for a long time in Ubuntu and other distros by using some init scripts and symlinks in /etc, but very recently (two days ago), this has now been implemented cleanly upstream.</p>
<p>So here’s how auto-started containers work nowadays:</p>
<p>As you may know, each container has a configuration file typically under
<tt class="docutils literal"><span class="pre">/var/lib/lxc/&lt;container</span> <span class="pre">name&gt;/config</span></tt></p>
<p>That file is key = value with the list of valid keys being specified in <a class="reference external" href="http://qa.linuxcontainers.org/master/current/doc/man/lxc.conf.5.html">lxc.conf(5)</a>.</p>
<p>The startup related values that are available are:</p>
<ul class="simple">
<li><tt class="docutils literal">lxc.start.auto = 0</tt> (disabled) or 1 (enabled)</li>
<li><tt class="docutils literal">lxc.start.delay = 0</tt> (delay in second to wait after starting the container)</li>
<li><tt class="docutils literal">lxc.start.order = 0</tt> (priority of the container, higher value means starts earlier)</li>
<li><tt class="docutils literal">lxc.group = group1,group2,group3,…</tt> (groups the container is a member of)</li>
</ul>
<p>When your machine starts, an init script will ask <tt class="docutils literal"><span class="pre">lxc-autostart</span></tt> to start all containers of a given group (by default, all containers which aren’t in any) in the right order and waiting the specified time between them.</p>
<p>To illustrate that, edit <tt class="docutils literal">/var/lib/lxc/p1/config</tt> and append those lines to the file:</p>
<pre class="code literal-block">
lxc.start.auto = 1
lxc.group = ubuntu
</pre>
<p>And <tt class="docutils literal">/var/lib/lxc/p2/config</tt> and append those lines:</p>
<pre class="code literal-block">
lxc.start.auto = 1
lxc.start.delay = 5
lxc.start.order = 100
</pre>
<p>Doing that means that only the p2 container will be started at boot time (since only those without a group are by default), the order value won’t matter since it’s alone and the init script will wait 5s before moving on.</p>
<p>You may check what containers are automatically started using <tt class="docutils literal"><span class="pre">lxc-ls</span></tt>:</p>
<pre class="code literal-block">
stgraber&#64;castiana:~$ sudo lxc-ls --fancy
NAME    STATE    IPV4        IPV6                                    AUTOSTART
---------------------------------------------------------------------------------
p1      RUNNING  10.0.3.128  2607:f2c0:f00f:2751:216:3eff:feb1:4c7f  YES (ubuntu)
p2      RUNNING  10.0.3.165  2607:f2c0:f00f:2751:216:3eff:fe3a:f1c1  YES
</pre>
<p>Now you can also manually play with those containers using the <tt class="docutils literal"><span class="pre">lxc-autostart</span></tt> command which let’s you start/stop/kill/reboot any container marked with <tt class="docutils literal">lxc.start.auto=1</tt>.</p>
<p>For example, you could do:</p>
<pre class="code literal-block">
sudo lxc-autostart -a
</pre>
<p>Which will start any container that has <tt class="docutils literal">lxc.start.auto=1</tt> (ignoring the lxc.group value) which in our case means it’ll first start p2 (because of order = 100), then wait 5s (because of delay = 5) and then start p1 and return immediately afterwards.</p>
<p>If at that point you want to reboot all containers that are in the <tt class="docutils literal">ubuntu</tt> group, you may do:</p>
<pre class="code literal-block">
sudo lxc-autostart -r -g ubuntu
</pre>
<p>You can also pass <tt class="docutils literal"><span class="pre">-L</span></tt> with any of those commands which will simply print which containers would be affected and what the delays would be but won’t actually do anything (useful to integrate with other scripts).</p>
</div>
<div class="section" id="freezing-your-containers">
<h2><a class="toc-backref" href="#id20">Freezing your containers</a></h2>
<p>Sometimes containers may be running daemons that take time to shutdown or restart, yet you don’t want to run the container because you’re not actively using it at the time.</p>
<p>In such cases, <tt class="docutils literal">sudo <span class="pre">lxc-freeze</span> <span class="pre">-n</span> &lt;container name&gt;</tt> can be used. That very simply freezes all the processes in the container so they won’t get any time allocated by the scheduler. However the processes will still exist and will still use whatever memory they used to.</p>
<p>Once you need the service again, just call <tt class="docutils literal">sudo <span class="pre">lxc-unfreeze</span> <span class="pre">-n</span> &lt;container name&gt;</tt> and all the processes will be restarted.</p>
</div>
<div class="section" id="networking">
<h2><a class="toc-backref" href="#id21">Networking</a></h2>
<p>As you may have noticed in the configuration file while you were setting the auto-start settings, LXC has a relatively flexible network configuration.
By default in Ubuntu we allocate one <tt class="docutils literal">veth</tt> device per container which is bridged into a <tt class="docutils literal">lxcbr0</tt> bridge on the host on which we run a minimal dnsmasq dhcp server.</p>
<p>While that’s usually good enough for most people. You may want something slightly more complex, such as multiple network interfaces in the container or passing through physical network interfaces, … The details of all of those options are listed in <a class="reference external" href="http://qa.linuxcontainers.org/master/current/doc/man/lxc.conf.5.html">lxc.conf(5)</a> so I won’t repeat them here, however here’s a quick example of what can be done.</p>
<pre class="code literal-block">
lxc.network.type = veth
lxc.network.hwaddr = 00:16:3e:3a:f1:c1
lxc.network.flags = up
lxc.network.link = lxcbr0
lxc.network.name = eth0

lxc.network.type = veth
lxc.network.link = virbr0
lxc.network.name = virt0

lxc.network.type = phys
lxc.network.link = eth2
lxc.network.name = eth1
</pre>
<p>With this setup my container will have 3 interfaces, <tt class="docutils literal">eth0</tt> will be the usual veth device in the <tt class="docutils literal">lxcbr0</tt> bridge, <tt class="docutils literal">eth1</tt> will be the host’s <tt class="docutils literal">eth2</tt> moved inside the container (it’ll disappear from the host while the container is running) and <tt class="docutils literal">virt0</tt> will be another veth device in the <tt class="docutils literal">virbr0</tt> bridge on the host.</p>
<p>Those last two interfaces don’t have a mac address or network flags set, so they’ll get a random mac address at boot time (non-persistent) and it’ll be up to the container to bring the link up.</p>
</div>
<div class="section" id="attach">
<h2><a class="toc-backref" href="#id22">Attach</a></h2>
<p>Provided you are running a sufficiently recent kernel, that is 3.8 or higher, you may use the <tt class="docutils literal"><span class="pre">lxc-attach</span></tt> tool. It’s most basic feature is to give you a standard shell inside a running container:</p>
<pre class="code literal-block">
sudo lxc-attach -n p1
</pre>
<p>You may also use it from scripts to run actions in the container, such as:</p>
<pre class="code literal-block">
sudo lxc-attach -n p1 -- restart ssh
</pre>
<p>But it’s a lot more powerful than that. For example, take:</p>
<pre class="code literal-block">
sudo lxc-attach -n p1 -e -s 'NETWORK|UTSNAME'
</pre>
<p>In that case, you’ll get a shell that says <tt class="docutils literal">root&#64;p1</tt> (thanks to <tt class="docutils literal">UTSNAME</tt>), running <tt class="docutils literal">ifconfig <span class="pre">-a</span></tt> from there will list the container’s network interfaces. But everything else will be that of the host. Also passing <tt class="docutils literal"><span class="pre">-e</span></tt> means that the cgroup, apparmor, … restrictions won’t apply to any processes started from that shell.</p>
<p>This can be very useful at times to spawn a software located on the host but inside the container’s network or pid namespace.</p>
</div>
<div class="section" id="passing-devices-to-a-running-container">
<h2><a class="toc-backref" href="#id23">Passing devices to a running container</a></h2>
<p>It’s great being able to enter and leave the container at will, but what about accessing some random devices on your host?</p>
<p>By default LXC will prevent any such access using the devices cgroup as a filtering mechanism. You could edit the container configuration to allow the right additional devices and then restart the container.</p>
<p>But for one-off things, there’s also a very convenient tool called <tt class="docutils literal"><span class="pre">lxc-device</span></tt>.
With it, you can simply do:</p>
<pre class="code literal-block">
sudo lxc-device add -n p1 /dev/ttyUSB0 /dev/ttyS0
</pre>
<p>Which will add (mknod) <tt class="docutils literal">/dev/ttyS0</tt> in the container with the same type/major/minor as <tt class="docutils literal">/dev/ttyUSB0</tt> and then add the matching cgroup entry allowing access from the container.</p>
<p>The same tool also allows moving network devices from the host to within the container.</p>
<!-- -*- coding: utf-8 -*- -->
</div>
</div>
<div class="section" id="id4">
<h1><a class="toc-backref" href="#id24">3. Advanced container usage</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/21</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>This is post 3 out of 10 in the <a class="reference external" href="../../_build/en/index.html#intro-blog-post-series">LXC 1.0 blog post series</a>.</p>
<div class="section" id="exchanging-data-with-a-container">
<h2><a class="toc-backref" href="#id25">Exchanging data with a container</a></h2>
<p>Because containers directly share their filesystem with the host, there’s a lot of things that can be done to pass data into a container or to get stuff out.</p>
<p>The first obvious one is that you can access the container’s root at:
<tt class="docutils literal"><span class="pre">/var/lib/lxc/&lt;container</span> <span class="pre">name&gt;/rootfs/</span></tt></p>
<p>That’s great, but sometimes you need to access data that’s in the container and on a filesystem which was mounted by the container itself (such as a tmpfs). In those cases, you can use this trick:</p>
<pre class="code literal-block">
sudo ls -lh /proc/$(sudo lxc-info -n p1 -p -H)/root/run/
</pre>
<p>Which will show you what’s in <tt class="docutils literal">/run</tt> of the running container <tt class="docutils literal">p1</tt>.</p>
<p>Now, that’s great to have access from the host to the container, but what about having the container access and write data to the host?
Well, let’s say we want to have our host’s <tt class="docutils literal">/var/cache/lxc</tt> shared with <tt class="docutils literal">p1</tt>, we can edit <tt class="docutils literal">/var/lib/lxc/p1/fstab</tt> and append:</p>
<pre class="code literal-block">
/var/cache/lxc var/cache/lxc none bind,create=dir
</pre>
<p>This line means, mount <tt class="docutils literal">/var/cache/lxc</tt> from the host as <tt class="docutils literal">/var/cache/lxc</tt> (the lack of initial / makes it relative to the container’s root), mount it as a bind-mount (<tt class="docutils literal">none</tt> fstype and <tt class="docutils literal">bind</tt> option) and create any directory that’s missing in the container (<tt class="docutils literal">create=dir</tt>).</p>
<p>Now restart <tt class="docutils literal">p1</tt> and you’ll see <tt class="docutils literal">/var/cache/lxc</tt> in there, showing the same thing as you have on the host. Note that if you want the container to only be able to read the data, you can simply add <tt class="docutils literal">ro</tt> as a mount flag in the fstab.</p>
</div>
<div class="section" id="container-nesting">
<h2><a class="toc-backref" href="#id26">Container nesting</a></h2>
<p>One pretty cool feature of LXC (though admittedly not very useful to most people) is support for nesting. That is, you can run LXC within LXC with pretty much no overhead.</p>
<p>By default this is blocked in Ubuntu as allowing this at the moment requires letting the container mount cgroupfs which will let it escape any cgroup restrictions that’s applied to it. It’s not an issue in most environment, but if you don’t trust your containers at all, then you shouldn’t be using nesting at this point.</p>
<p>So to enable nesting for our <tt class="docutils literal">p1</tt> container, edit <tt class="docutils literal">/var/lib/lxc/p1/config</tt> and add:</p>
<pre class="code literal-block">
lxc.aa_profile = lxc-container-default-with-nesting
</pre>
<p>And then restart <tt class="docutils literal">p1</tt>. Once that’s done, install lxc inside the container. I usually recommend using the same version as the host, though that’s not strictly required.</p>
<p>Once LXC is installed in the container, run:</p>
<pre class="code literal-block">
sudo lxc-create -t ubuntu -n p1
</pre>
<p>As you’ve previously bind-mounted <tt class="docutils literal">/var/cache/lxc</tt> inside the container, this should be very quick (it shouldn’t rebootstrap the whole environment). Then start that new container as usual.</p>
<p>At that point, you may now run <tt class="docutils literal"><span class="pre">lxc-ls</span></tt> on the host in nesting mode to see exactly what’s running on your system:</p>
<pre class="code literal-block">
stgraber&#64;castiana:~$ sudo lxc-ls --fancy --nesting
NAME    STATE    IPV4                 IPV6   AUTOSTART
------------------------------------------------------
p1      RUNNING  10.0.3.82, 10.0.4.1  -      NO
 \_ p1  RUNNING  10.0.4.7             -      NO
p2      RUNNING  10.0.3.128           -      NO
</pre>
<p>There’s no real limit to the number of level you can go, though as fun as it may be, it’s hard to imagine why 10 levels of nesting would be of much use to anyone :)</p>
</div>
<div class="section" id="raw-network-access">
<h2><a class="toc-backref" href="#id27">Raw network access</a></h2>
<p>In the previous post I mentioned passing raw devices from the host inside the container. One such container I use relatively often is when working with a remote network over a VPN. That network uses OpenVPN and a raw ethernet tap device.</p>
<p>I needed to have a completely isolated system access that VPN so I wouldn’t get mixed routes and it’d appear just like any other machine to the machines on the remote site.</p>
<p>All I had to do to make this work was set my container’s network configuration to:</p>
<pre class="code literal-block">
lxc.network.type = phys
lxc.network.hwaddr = 00:16:3e:c6:0e:04
lxc.network.flags = up
lxc.network.link = tap0
lxc.network.name = eth0
</pre>
<p>Then all I have to do is start OpenVPN on my host which will connect and setup <tt class="docutils literal">tap0</tt>, then start the container which will steal that interface and use it as its own <tt class="docutils literal">eth0</tt>.The container will then use DHCP to grab an IP and will behave just like if it was a physical machine connect directly in the remote network.</p>
<!-- -*- coding: utf-8 -*- -->
</div>
</div>
<div class="section" id="id6">
<h1><a class="toc-backref" href="#id28">4. Some more advanced container usage</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/23</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>This is post 4 out of 10 in the <a class="reference external" href="../../_build/en/index.html#intro-blog-post-series">LXC 1.0 blog post series</a>.</p>
<div class="section" id="running-foreign-architectures">
<h2><a class="toc-backref" href="#id29">Running foreign architectures</a></h2>
<p>By default LXC will only let you run containers of one of the architectures supported by the host. That makes sense since after all, your CPU doesn’t know what to do with anything else.</p>
<p>Except that we have this convenient package called <tt class="docutils literal"><span class="pre">qemu-user-static</span></tt> which contains a whole bunch of emulators for quite a few interesting architectures. The most common and useful of those is qemu-arm-static which will let you run most armv7 binaries directly on x86.</p>
<p>The <tt class="docutils literal">ubuntu</tt> template knows how to make use of <tt class="docutils literal"><span class="pre">qemu-user-static</span></tt>, so you can simply check that you have the <tt class="docutils literal"><span class="pre">qemu-user-static</span></tt> package installed, then run:</p>
<pre class="code literal-block">
sudo lxc-create -t ubuntu -n p3 -- -a armhf
</pre>
<p>After a rather long bootstrap, you’ll get a new <tt class="docutils literal">p3</tt> container which will be mostly running Ubuntu armhf. I’m saying mostly because the qemu emulation comes with a few limitations, the biggest of which is that any piece of software using the <tt class="docutils literal">ptrace()</tt> syscall will fail and so will anything using netlink. As a result, LXC will install the host architecture version of upstart and a few of the networking tools so that the containers can boot properly.</p>
<pre class="code literal-block">
stgraber&#64;castiana:~$ file /bin/ls
/bin/ls: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV),
dynamically linked (uses shared libs), for GNU/Linux 2.6.24,
&quot;&quot;BuildID[sha1]&quot;&quot; =e50e0a5dadb8a7f4eaa2fd715cacb9842e157dc7, stripped
stgraber&#64;castiana:~$ sudo lxc-start -n p3 -d
stgraber&#64;castiana:~$ sudo lxc-attach -n p3
root&#64;p3:/# file /bin/ls
/bin/ls: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),
dynamically linked (uses shared libs), for GNU/Linux 2.6.32,
&quot;&quot;BuildID[sha1]&quot;&quot; =88ff013a8fd9389747fb1fea1c898547fb0f650a, stripped
root&#64;p3:/# exit
stgraber&#64;castiana:~$ sudo lxc-stop -n p3
stgraber&#64;castiana:~$
</pre>
</div>
<div class="section" id="hooks">
<h2><a class="toc-backref" href="#id30">Hooks</a></h2>
<p>As we know people like to script their containers and that our configuration can’t always accommodate every single use case, we’ve introduced a set of hooks which you may use.</p>
<p>Those hooks are simple paths to an executable file which LXC will run at some specific time in the lifetime of the container. Those executables will also be passed a set of useful environment variables so they can easily know what container invoked them and what to do.</p>
<p>The currently available hooks are (details in <a class="reference external" href="http://qa.linuxcontainers.org/master/current/doc/man/lxc.conf.5.html">lxc.conf(5)</a>):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">lxc.hook.pre-start</span></tt> (called before any initialization is done)</li>
<li><tt class="docutils literal"><span class="pre">lxc.hook.pre-mount</span></tt> (called after creating the mount namespace but before mounting anything)</li>
<li><tt class="docutils literal">lxc.hook.mount</tt> (called after the mounts but before pivot_root)</li>
<li><tt class="docutils literal">lxc.hook.autodev</tt> (identical to mount but only called if using <tt class="docutils literal">autodev</tt>)</li>
<li><tt class="docutils literal">lxc.hook.start</tt> (called in the container right before <tt class="docutils literal">/sbin/init</tt>)</li>
<li><tt class="docutils literal"><span class="pre">lxc.hook.post-stop</span></tt> (run after the container has been shutdown)</li>
<li><tt class="docutils literal">lxc.hook.clone</tt> (called when cloning a container into a new one)</li>
</ul>
<p>Additionally each network section may also define two additional hooks:</p>
<ul class="simple">
<li><tt class="docutils literal">lxc.network.script.up</tt> (called in the network namespace after the interface was created)</li>
<li><tt class="docutils literal">lxc.network.script.down</tt> (called in the network namespace before destroying the interface)</li>
</ul>
<p>All of those hooks may be specified as many times as you want in the configuration so you can use each hooking point multiple times.</p>
<p>As a simple example, let’s add the following to our <tt class="docutils literal">p1</tt> container:</p>
<pre class="code literal-block">
lxc.hook.pre-start = /var/lib/lxc/p1/pre-start.sh
</pre>
<p>And create the hook itself at <tt class="docutils literal"><span class="pre">/var/lib/lxc/p1/pre-start.sh</span></tt>:</p>
<pre class="code literal-block">
#!/bin/sh
echo &quot;arguments: $*&quot; &gt; /tmp/test
echo &quot;environment:&quot; &gt;&gt; /tmp/test
env | grep LXC &gt;&gt; /tmp/test
</pre>
<p>Make it executable (<tt class="docutils literal">chmod 755</tt>) and then start the container.
Checking <tt class="docutils literal">/tmp/test</tt> you should see:</p>
<pre class="code literal-block">
arguments: p1 lxc pre-start
environment:
LXC_ROOTFS_MOUNT=/usr/lib/x86_64-linux-gnu/lxc
LXC_CONFIG_FILE=/var/lib/lxc/p1/config
LXC_ROOTFS_PATH=/var/lib/lxc/p1/rootfs
LXC_NAME=p1
</pre>
</div>
<div class="section" id="android-containers">
<h2><a class="toc-backref" href="#id31">Android containers</a></h2>
<p>I’ve often been asked whether it was possible to run Android in an LXC container. Well, the short answer is yes. However it’s not very simple and it really depends on what you want to do with it.</p>
<p>The first thing you’ll need if you want to do this is get your machine to run an Android kernel, you’ll need to have any modules needed by Android built and loaded before you can start the container.</p>
<p>Once you have that, you’ll need to create a new container by hand.
Let’s put it in <tt class="docutils literal">/var/lib/lxc/android/</tt>, in there, you need a configuration file similar to this one:</p>
<pre class="code literal-block">
lxc.rootfs = /var/lib/lxc/android/rootfs
lxc.utsname = armhf

lxc.network.type = none

lxc.devttydir = lxc
lxc.tty = 4
lxc.pts = 1024
lxc.arch = armhf
lxc.cap.drop = mac_admin mac_override
lxc.pivotdir = lxc_putold

lxc.hook.pre-start = /var/lib/lxc/android/pre-start.sh

lxc.aa_profile = unconfined
</pre>
<p><tt class="docutils literal"><span class="pre">/var/lib/lxc/android/pre-start.sh</span></tt> is where the interesting bits happen. It needs to be an executable shell script, containing something along the lines of:</p>
<pre class="code literal-block">
#!/bin/sh
mkdir -p $LXC_ROOTFS_PATH
mount -n -t tmpfs tmpfs $LXC_ROOTFS_PATH

cd $LXC_ROOTFS_PATH
cat /var/lib/lxc/android/initrd.gz | gzip -d | cpio -i

# Create /dev/pts if missing
mkdir -p $LXC_ROOTFS_PATH/dev/pts
</pre>
<p>Then get the initrd for your device and place it in <tt class="docutils literal">/var/lib/lxc/android/initrd.gz</tt>.</p>
<p>At that point, when starting the LXC container, the Android initrd will be unpacked on a tmpfs (similar to Android’s ramfs) and Android’s init will be started which in turn should mount any partition that Android requires and then start all of the usual services.</p>
<p>Because there are no apparmor, cgroup or even network configuration applied to it, the container will have a lot of rights and will typically completely crash the machine. You unfortunately have to be familiar with the way Android works and not be afraid to modify its init scripts if not even its init process to only start the bits you actually want.</p>
<p>I can’t provide a generic recipe there as it completely depends on what you’re interested on, what version of Android and what device you’re using. But it’s clearly possible to do and you may want to look at Ubuntu Touch to see how we’re doing it by default there.</p>
<p>One last note, Android’s init script isn’t in <tt class="docutils literal">/sbin/init</tt>, so you need to tell LXC where to load it with:</p>
<pre class="code literal-block">
lxc-start -n android -- /init
</pre>
</div>
<div class="section" id="lxc-on-android-devices">
<h2><a class="toc-backref" href="#id32">LXC on Android devices</a></h2>
<p>So now that we’ve seen how to run Android in LXC, let’s talk about running Ubuntu on Android in LXC.</p>
<p>LXC has been ported to bionic (Android’s C library) and while not feature-equivalent with its glibc build, it’s still good enough to be used.</p>
<p>Unfortunately due to the kind of low level access LXC requires and the fact that our primary focus isn’t Android, installation could be easier…You won’t be finding LXC on the Google PlayStore and we won’t provide you with a .apk that you can install.</p>
<p>Instead every time something changes in the upstream git branch, we produce a new tarball which can be downloaded here: <a class="reference external" href="http://qa.linuxcontainers.org/master/current/android-armel/lxc-android.tar.gz">http://qa.linuxcontainers.org/master/current/android-armel/lxc-android.tar.gz</a></p>
<p>This build is known to work with Android &gt;= 4.2 but will quite likely work on older versions too.</p>
<p>For this to work, you’ll need to grab your device’s kernel configuration and run <tt class="docutils literal"><span class="pre">lxc-checkconfig</span></tt> against it to see whether it’s compatible with LXC or not. Unfortunately it’s very likely that it won’t be… In that case, you’ll need to go hunt for the kernel source for your device, add the missing feature flags, rebuild it and update your device to boot your updated kernel.</p>
<p>As scary as this may sound, it’s usually not that difficult as long as your device is unlocked and you’re already using an alternate ROM like Cyanogen which usually make their kernel git tree easily available.</p>
<p>Once your device has a working kernel, all you need to do is unpack our tarball as root in your device’s <tt class="docutils literal">/</tt> directory, copy an arm container to <tt class="docutils literal"><span class="pre">/data/lxc/containers/&lt;container</span> name&gt;</tt>, get into <tt class="docutils literal">/data/lxc</tt> and run <tt class="docutils literal"><span class="pre">./run-lxc</span> <span class="pre">lxc-start</span> <span class="pre">-n</span> &lt;container name&gt;”</tt>.
A few seconds later you’ll be greeted by a login prompt.</p>
<!-- -*- coding: utf-8 -*- -->
</div>
</div>
<div class="section" id="id8">
<h1><a class="toc-backref" href="#id33">5. Container storage</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2013/12/27</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stéphane Graber</td>
</tr>
</tbody>
</table>
<p>This is post 5 out of 10 in the <a class="reference external" href="../../_build/en/index.html#intro-blog-post-series">LXC 1.0 blog post series</a>.</p>
<div class="section" id="storage-backingstores">
<h2><a class="toc-backref" href="#id34">Storage backingstores</a></h2>
<p>LXC supports a variety of storage backends (also referred to as
backingstore).
It defaults to none which simply stores the rootfs under
<tt class="docutils literal"><span class="pre">/var/lib/lxc/&lt;container&gt;/rootfs</span></tt> but you can specify something else to
<tt class="docutils literal"><span class="pre">lxc-create</span></tt> or <tt class="docutils literal"><span class="pre">lxc-clone</span></tt> with the <tt class="docutils literal"><span class="pre">-B</span></tt> option.</p>
<p>Currently supported values are:</p>
<div class="section" id="directory-based-storage-none-and-dir">
<h3><a class="toc-backref" href="#id35">directory based storage (none and dir)</a></h3>
<p>This is the default backingstore, the container rootfs is stored under
<tt class="docutils literal"><span class="pre">/var/lib/lxc/&lt;container&gt;/rootfs</span></tt></p>
<p>The <tt class="docutils literal"><span class="pre">--dir</span></tt> option (when using dir) can be used to override the path.</p>
</div>
<div class="section" id="btrfs">
<h3><a class="toc-backref" href="#id36">btrfs</a></h3>
<p>With this backingstore LXC will setup a new subvolume for the
container which makes snapshotting much easier.</p>
</div>
<div class="section" id="lvm">
<h3><a class="toc-backref" href="#id37">lvm</a></h3>
<p>This one will use a new logical volume for the container.
The LV can be set with <tt class="docutils literal"><span class="pre">--lvname</span></tt> (the default is the container name).
The VG can be set with <tt class="docutils literal"><span class="pre">--vgname</span></tt> (the default is lxc).
The filesystem can be set with <tt class="docutils literal"><span class="pre">--fstype</span></tt> (the default is ext4).
The size can be set with <tt class="docutils literal"><span class="pre">--fssize</span></tt> (the default is 1G).
You can also use LVM thinpools with <tt class="docutils literal"><span class="pre">--thinpool</span></tt></p>
</div>
<div class="section" id="overlayfs">
<h3><a class="toc-backref" href="#id38">overlayfs</a></h3>
<p>This one is mostly used when cloning containers to create a container
based on another one and storing any changes in an overlay.</p>
<p>When used with <tt class="docutils literal"><span class="pre">lxc-create</span></tt> it'll create a container where any change
done after its initial creation will be stored in a delta0 directory
next to the containers rootfs.</p>
</div>
<div class="section" id="zfs">
<h3><a class="toc-backref" href="#id39">zfs</a></h3>
<p>Very similar to btrfs, as Ive not used either of those myself I cant
say much about them besides that it should also create some kind of
subvolume for the container and make snapshots and clones faster and
more space efficient.</p>
</div>
</div>
<div class="section" id="standard-paths">
<h2><a class="toc-backref" href="#id40">Standard paths</a></h2>
<p>One quick word with the way LXC usually works and where its storing
its files:</p>
<ul class="simple">
<li><tt class="docutils literal">/var/lib/lxc</tt> (default location for containers)</li>
<li><tt class="docutils literal">/var/lib/lxcsnap</tt> (default location for snapshots)</li>
<li><tt class="docutils literal">/var/cache/lxc</tt> (default location for the template cache)</li>
<li><tt class="docutils literal"><span class="pre">$HOME/.local/share/lxc</span></tt> (default location for unprivileged
containers)</li>
<li><tt class="docutils literal"><span class="pre">$HOME/.local/share/lxcsnap</span></tt> (default location for unprivileged
snapshots)</li>
<li><tt class="docutils literal"><span class="pre">$HOME/.cache/lxc</span></tt> (default location for unprivileged template cache)</li>
</ul>
<p>The default path, also called <tt class="docutils literal">lxcpath</tt> can be overridden on the command
line with the <tt class="docutils literal"><span class="pre">-P</span></tt> option or once and for all by setting <tt class="docutils literal">lxcpath =
/new/path</tt> in <tt class="docutils literal">/etc/lxc/lxc.conf</tt> (or <tt class="docutils literal"><span class="pre">$HOME/.config/lxc/lxc.conf</span></tt> for
unprivileged containers).</p>
<p>The snapshot directory is always snap appended to lxcpath so it'll
magically follow <tt class="docutils literal">lxcpath</tt>. The template cache is unfortunately
hardcoded and cant easily be moved short of relying on bind-mounts or
symlinks.</p>
<p>The default configuration used for all containers at creation time is
taken from
<tt class="docutils literal">/etc/lxc/default.conf</tt> (no unprivileged equivalent yet).
The templates themselves are stored in <tt class="docutils literal">/usr/share/lxc/templates</tt>.</p>
</div>
<div class="section" id="cloning-containers">
<h2><a class="toc-backref" href="#id41">Cloning containers</a></h2>
<p>All those backingstores only really shine once you start cloning
containers.
For example, lets take our good old <tt class="docutils literal">p1 Ubuntu</tt> container and lets say
you want to make a usable copy of it called <tt class="docutils literal">p4</tt>, you can simply do:</p>
<pre class="code literal-block">
sudo lxc-clone -o p1 -n p4
</pre>
<p>And there you go, youve got a working <tt class="docutils literal">p4</tt> container thatll be a simple
copy of <tt class="docutils literal">p1</tt> but with a new mac address and its hostname properly set.</p>
<p>Now lets say you want to do a quick test against <tt class="docutils literal">p1</tt> but dont want to
alter that container itself, yet you dont want to wait the time needed
for a full copy, you can simply do:</p>
<pre class="code literal-block">
sudo lxc-clone -o p1 -n p1-test -B overlayfs -s
</pre>
<p>And there you go, youve got a new p1-test container which is entirely
based on the <tt class="docutils literal">p1</tt> rootfs and where any change will be stored in the
<tt class="docutils literal">delta0</tt> directory of <tt class="docutils literal"><span class="pre">p1-test</span></tt>.
The same <tt class="docutils literal"><span class="pre">-s</span></tt> option also works with lvm and btrfs (possibly zfs too)
containers and tells <tt class="docutils literal"><span class="pre">lxc-clone</span></tt> to use a snapshot rather than copy the
whole rootfs across.</p>
</div>
<div class="section" id="snapshotting">
<h2><a class="toc-backref" href="#id42">Snapshotting</a></h2>
<p>So cloning is nice and convenient, great for things like development
environments where you want throw away containers. But in production,
snapshots tend to be a whole lot more useful for things like backup or
just before you do possibly risky changes.</p>
<p>In LXC we have a <tt class="docutils literal"><span class="pre">lxc-snapshot</span></tt> tool which will let you create, list,
restore and destroy snapshots of your containers.
Before I show you how it works, please note that <tt class="docutils literal"><span class="pre">lxc-snapshot</span></tt>
currently doesnt appear to work with directory based containers. With
those it produces an empty snapshot, this should be fixed by the time
LXC 1.0 is actually released.</p>
<p>So, lets say we want to backup our p1-lvm container before installing
apache2 into it, simply run:</p>
<pre class="code literal-block">
echo &quot;before installing apache2&quot; &gt; snap-comment
sudo lxc-snapshot -n p1-lvm -c snap-comment
</pre>
<p>At which point, you can confirm the snapshot was created with:</p>
<pre class="code literal-block">
sudo lxc-snapshot -n p1-lvm -L -C
</pre>
<p>Now you can go ahead and install apache2 in the container.</p>
<p>If you want to revert the container at a later point, simply use:</p>
<pre class="code literal-block">
sudo lxc-snapshot -n p1-lvm -r snap0
</pre>
<p>Or if you want to restore a snapshot as its own container, you can
use:</p>
<pre class="code literal-block">
sudo lxc-snapshot -n p1-lvm -r snap0 p1-lvm-snap0
</pre>
<p>And youll get a new <tt class="docutils literal"><span class="pre">p1-lvm-snap0</span></tt> container which will contain a
working copy of <tt class="docutils literal"><span class="pre">p1-lvm</span></tt> as it was at <tt class="docutils literal">snap0</tt>.</p>
</div>
</div>
</div>
</body>
</html>
